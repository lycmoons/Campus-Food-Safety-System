import numpy as np

def dataset(N):
    # class 0
    xy_c1 = np.random.randn(N, 2)  # 利用标准正态分布创建N行2列的矩阵，N个二维点，来自标准正态分布（均值为0，方差为1）
    x1 = xy_c1[:, 0].T # 取所有点的x坐标
    y1 = xy_c1[:, 1].T # 取所有点的y坐标
    data_0 = [(0, x, y) for x, y in zip(x1, y1)]
    '''
    这部分生成了属于 类 0 的 N 个样本，每个样本是二维坐标 (x, y)，且满足标准正态分布（中心在原点的高斯分布）。
    最终每个数据点格式是 (label, x, y)，其中 label=0。
    '''
    # class 1
    xy_c2 = np.random.randn(2 * N, 2)  # 利用标准正态分布创建2N行2列的矩阵，生成2N个点
    x2 = 2 * xy_c2[:, 0].T # 放大两倍，x坐标
    y2 = 2 * xy_c2[:, 1].T # 放大两倍，y坐标
    data_1 = [(1, x, y) for x, y in zip(x2, y2) if x ** 2 + y ** 2 > 4 and x + y < 0]
    '''
    这部分生成了属于 类 1 的数据点。原始数据同样是正态分布的，但通过 ×2 放大了范围，使其更容易落在远离原点的位置。

    然后通过筛选条件：
    x^2 + y^2 > 4：距离原点超过半径 2 的点（在圆外）
    x + y < 0：位于 x+y=0 以下的点（靠左下角）

    这些条件帮助你构造一个与类 0 分布重叠较小的类 1 区域，从而构造出分布不同的两个类别。
    '''
    # 将类 0 和类 1 的数据合并，并随机打乱顺序，方便训练时不会因样本顺序影响模型学习。
    data = np.concatenate((data_0, data_1), 0)
    np.random.shuffle(data)

    # 最终返回的数据是一个形如 (label, x, y) 的元组列表，可以直接用于训练分类模型。
    return data
